<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jihoo Kang&#39;s Blog</title>
    <link>https://jihookang-kor.github.io/posts/</link>
    <description>Recent content in Posts on Jihoo Kang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 20 Apr 2023 20:22:21 +0900</lastBuildDate><atom:link href="https://jihookang-kor.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Coding Practice] 대충 만든 자판</title>
      <link>https://jihookang-kor.github.io/posts/roughly-made-keyboard/</link>
      <pubDate>Thu, 20 Apr 2023 20:22:21 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/roughly-made-keyboard/</guid>
      
        <description>대충 만든 자판 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
이 문제는 keymap과 target의 최대 길이가 각각 100이므로 3중 반복문까지 사용해도 해결이 가능하겠다는 생각이 들었습니다. 그래서 target의 각 글자를 몇 번이나 keymap에서 눌러야하는지 keymap의 최소값을 삼항연산자로 찾아내는 로직을 작성하였고, keymap의 구성 중 target의 글자가 없는 경우는 continue로 반복문의 한 사이클만 넘기는 방법을 사용하였습니다.
class Solution { public int[] solution(String[] keymap, String[] targets) { // keymap의 모든 원소에서 각각 for문으로 // targets 각 요소의 각 글자들의 위치를 찾는다.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 햄버거 만들기</title>
      <link>https://jihookang-kor.github.io/posts/making-hamburger/</link>
      <pubDate>Wed, 19 Apr 2023 20:11:07 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/making-hamburger/</guid>
      
        <description>햄버거 만들기 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
이 문제는 특정 패턴이 존재할 때마다 answer에 1씩 더해주면 되는 것이기 때문에 처음에는 아래 코드와 같이 문자열로 바꿔서 해당 패턴이 있을 때마다 찾아서 제거하는 방식으로 진행하였습니다. 그러나 아무리 효율적으로 하려고 해도 테스트 케이스 1개가 마지막까지 통과되지 못해서 할 수 없이 다른 방법을 생각해보기로 하였습니다.
import java.util.*; class Solution { public int solution(int[] ingredient) { int answer = 0; // ingredient를 String으로 만든 후 &amp;#34;1231&amp;#34; 패턴이 나올 때마다 substring으로 제거.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 완주하지 못한 선수</title>
      <link>https://jihookang-kor.github.io/posts/unfinished-player/</link>
      <pubDate>Tue, 18 Apr 2023 19:03:24 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/unfinished-player/</guid>
      
        <description>완주하지 못한 선수 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
이 문제는 동명이인이 존재하는 경우도 고려해서 완주하지 못한 선수 한 명을 찾아내는 문제입니다. 처음에 시도했던 방법은 중복되는 요소를 없애기 위해 간단하게 HashSet으로 변경 후 순회 중에 값이 존재할 경우 해당 Set에서 그 값을 제거하는 식이었습니다. 그러나 이 방법은 동명이인이 3명 이상일 경우에는 2명째에 Set에서 값이 없어져버려 더 이상 확인이 불가능하다는 문제가 있었습니다. 그래서 두 번째 방법으로 HashMap을 사용하여 key에는 이름, value에는 이름의 등장 횟수를 저장하여 문제를 해결하였습니다.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 명예의 전당 (1)</title>
      <link>https://jihookang-kor.github.io/posts/hall-of-fame1/</link>
      <pubDate>Mon, 17 Apr 2023 19:37:39 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/hall-of-fame1/</guid>
      
        <description>명예의 전당 (1) 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
이 문제의 요구사항은 정해진 리스트의 크기만큼만 점수를 저장 가능하고 그 중에서 최저값을 answer에 저장하는 것입니다. 요소의 정렬 및 삭제를 용이하게 하기 위해서 ArrayList를 사용하였고, hallOfFame 리스트의 크기가 k보다 커졌을 때 바로 제일 작은 크기의 요소를 제거해주면 되는데 내림차순이 되어있으므로 맨 마지막 인덱스의 값을 제거해주면 됩니다.
import java.util.*; class Solution { public int[] solution(int k, int[] score) { // answer는 score의 길이만큼 설정.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 체육복</title>
      <link>https://jihookang-kor.github.io/posts/sportswear/</link>
      <pubDate>Sun, 16 Apr 2023 21:15:28 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/sportswear/</guid>
      
        <description>체육복 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
주석에 설명되어있지만 이 문제는 lost에 있는 요소를 최대한 많이 줄여야 하기 때문에 lost 요소 개수를 줄여나가기만 하면 최적의 해를 구할 수 있습니다. 그러나 그 전에 먼저 예비 체육복을 가지고 있어도 그것이 없어졌다면 어차피 옆사람에게 빌려줄 수가 없으므로 lost와 reserve에 중복되는 요소들이 있다면 미리 제거를 해줍니다. 학생 수가 최대 30명 정도이기 때문에 이 경우에는 배열을 하나 만들어 각 인덱스가 학생 번호를 나타낼 수 있도록 해주는 것이 좋습니다.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 카드 뭉치</title>
      <link>https://jihookang-kor.github.io/posts/card-set/</link>
      <pubDate>Sat, 15 Apr 2023 21:50:35 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/card-set/</guid>
      
        <description>카드 뭉치 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
본 문제는 단어들을 순서대로 사용해야하므로 Queue를 이용하여 해결하였습니다. 만들어야 하는 단어 배열인 goalQueue가 다 비어야 Yes라는 답이 나오는데, cardQueue1과 cardQueue2가 각각 먼저 다 비어버렸을 때의 상황도 역시 처리해줘야 합니다. 이 경우에는 아직 goalQueue가 다 없어지지 않았는데도 둘 중 한 쪽이 비었으므로 나머지 한 쪽과 goalQueue를 peek()해서 일치하지 않으면 바로 반복문을 탈출하도록 하였습니다.
import java.util.*; class Solution { public String solution(String[] cards1, String[] cards2, String[] goal) { // 모든 배열을 Queue로 만든 뒤에 peek을 사용하여 goal과 값 비교, // 있으면 poll()로 제거.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 기사단원의 무기</title>
      <link>https://jihookang-kor.github.io/posts/weapon-of-knights/</link>
      <pubDate>Fri, 14 Apr 2023 20:23:25 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/weapon-of-knights/</guid>
      
        <description>기사단원의 무기 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
해당 문제는 결국 약수의 개수를 구하는 로직이 중점이 된다고 생각하는데, 저는 iterator를 2부터 시작하여 나눠지는 숫자가 나오면 더 이상 나누어 떨어지지 않을 때까지 나눈 뒤에 iterator를 다음 수로 바꿔주는 방식을 사용하였습니다. 처음 2를 제외하고는 다음 수 부터 굳이 짝수를 순회할 필요가 없으므로 3부터는 2씩 더하여 개수를 계산하였습니다. 소수만 순회할 수 있으면 좋았겠지만 더 복잡해질 것 같아서 홀수를 순회하는 방향으로 정했습니다.
class Solution { public int solution(int number, int limit, int power) { int answer = 0; // for문으로 순회하여 구한 약수의 개수를 저장.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 덧칠하기</title>
      <link>https://jihookang-kor.github.io/posts/touch-up-paint/</link>
      <pubDate>Fri, 14 Apr 2023 20:14:34 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/touch-up-paint/</guid>
      
        <description>덧칠하기 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
해당 문제는 원래 Arrays.copyOfRange()를 이용하여 덧칠한 section을 제거하는 로직으로 해결하려고 했었습니다. 그러나 계속 시간초과가 일어나서 Arrays.copyOfRange()를 주석처리 해놓고 실행했더니 적어도 시간이 초과하지는 않는 것을 발견하고 다른 방법을 찾았고, 굳이 배열의 요소를 제거하지 않고 index만 규칙에 맞게 옮기면서 덧칠 횟수를 찾는 로직을 다시 작성하였습니다.
import java.util.*; class Solution { public int solution(int n, int m, int[] section) { // 최소값에서 m 만큼 더한 값 바로 전 값까지 배열에서 제거 후 answer++.</description>
      
    </item>
    
    <item>
      <title>[Coding Practice] 푸드 파이트 대회</title>
      <link>https://jihookang-kor.github.io/posts/food-fight-contest/</link>
      <pubDate>Thu, 13 Apr 2023 21:42:03 +0900</pubDate>
      
      <guid>https://jihookang-kor.github.io/posts/food-fight-contest/</guid>
      
        <description>푸드 파이트 대회 문제에 대한 설명은 프로그래머스 사이트를 참조바랍니다.
문제에서 원하는 것은 0으로 되어있는 가운데를 중심으로 양쪽이 대칭이 되는 숫자 구조인 String을 반환하는 것입니다. 그래서 저는 Stack을 이용하여 구현하였고, 먼저 Stack에 저장하면서 answer에도 같은 수를 추가하고 answer에 0을 더 추가한 뒤, Stack에 저장되어 있던 수를 차례대로 pop()으로 제거하면서 다시 answer에 같은 수를 저장하여 문제를 해결하였습니다.
구체적인 코드는 아래와 같습니다.
import java.util.*; class Solution { public String solution(int[] food) { // 가운데 0을 중심으로 양쪽이 대칭이다.</description>
      
    </item>
    
  </channel>
</rss>